//--------------------------------------------------------------------------------------
// Copyright 2014 Intel Corporation
// All Rights Reserved
//
// Permission is granted to use, copy, distribute and prepare derivative works of this
// software for any purpose and without fee, provided, that the above copyright notice
// and this statement appear in all copies.  Intel makes no representations about the
// suitability of this software for any purpose.  THIS SOFTWARE IS PROVIDED "AS IS."
// INTEL SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, AND ALL LIABILITY,
// INCLUDING CONSEQUENTIAL AND OTHER INDIRECT DAMAGES, FOR THE USE OF THIS SOFTWARE,
// INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PROPRIETARY RIGHTS, AND INCLUDING THE
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Intel does not
// assume any responsibility for any errors which may appear in this software nor any
// responsibility to update it.
//--------------------------------------------------------------------------------------
// Generated by ShaderGenerator.exe version 0.13
//--------------------------------------------------------------------------------------

// -------------------------------------
cbuffer cbPerModelValues
{
    float4x4 World                  : WORLD;
    float4x4 NormalMatrix           : WORLD;
    float4x4 WorldViewProjection    : WORLDVIEWPROJECTION;
    float4x4 InverseWorld           : WORLDINVERSE;
    float4x4 LightWorldViewProjection;

    float4   BoundingBoxCenterWorldSpace    < string UIWidget = "None"; > ;
    float4   BoundingBoxHalfWorldSpace      < string UIWidget = "None"; > ;
    float4   BoundingBoxCenterObjectSpace   < string UIWidget = "None"; > ;
    float4   BoundingBoxHalfObjectSpace     < string UIWidget = "None"; > ;
};

// -------------------------------------
cbuffer cbPerFrameValues
{
    float4x4  View                      < string UIWidget = "None"; >;
    float4x4  InverseView : ViewInverse < string UIWidget = "None"; > ;
    float4x4  Projection                < string UIWidget = "None"; >;
    float4x4  ViewProjection            < string UIWidget = "None"; >;
    float4    AmbientColor              < string UIWidget = "None"; > = .20;
    float4    LightColor                < string UIWidget = "None"; > = 1.0f;
    float4    LightDirection : Direction < string UIName = "Light Direction";  string Object = "TargetLight"; string Space = "World"; int Ref_ID = 0; > = { 0, 0, -1, 0 };
    float4    EyePosition               < string UIWidget = "None"; >;
    float4    TotalTimeInSeconds        < string UIWidget = "None"; > ;
};

cbuffer cbExternals
{
    float4 gBaseColor   < string UIName = "Base Color"; >;
    float2 btScale      < string UIName = "Base Texture UV Repeat"; >;
    float  gRoughness   < string UIName = "Roughness"; >;
    float  gMetal       < string UIName = "Metal"; >;
    float  gAmbient     < string UIName = "Ambient"; >;
    float  gCavity      < string UICavity = "Cavity"; >;

    bool   gUseBaseTexture      < string UIName = "Use Texture for Base Color"; >;
    bool   gUseNormalTexture    < string UIName = "Use Normal Map"; >;
    bool   gUseRMACTexture      < string UIName = "Use Roughness, Metal, Ambient, Cavity Texture"; >;
    bool   gUseRoughnessTexture < string UIName = "Use Roughness Texture"; >;
    bool   gUseMetalTexture     < string UIName = "Use Metal Texture"; >;
    bool   gUseAmbientTexture   < string UIName = "Use Ambient Texture"; >;
    bool   gUseCavityTexture    < string UIName = "Use Cavity Texture"; >;
};
// -------------------------------------
struct VS_INPUT
{
    float3 Position : POSITION; // Projected position
    float3 Normal   : NORMAL;
    float2 UV0      : TEXCOORD0;

    float3 Tangent  : TANGENT;
    float3 Binormal : BINORMAL;
};

// -------------------------------------
struct PS_INPUT
{
    float4 Position     : SV_POSITION;
    float3 Normal       : NORMAL;
    float2 UV0          : TEXCOORD0;
    float4 LightUV      : TEXCOORD1;
    float3 WorldPosition: TEXCOORD2;
    float3 Tangent      : TANGENT;
    float3 Binormal     : BINORMAL;
    //float3 Reflection : TEXCOORD3;
};

// -------------------------------------
SamplerState SAMPLER0  : register(s0);
SamplerComparisonState SHADOW_SAMPLER : register(s1);

Texture2D   BaseTexture       : register(t0);
Texture2D   NormalTexture     : register(t1);
Texture2D   RMACTexture       : register(t2);
Texture2D   RoughnessTexture  : register(t3);
Texture2D   MetalTexture      : register(t4);
Texture2D   AmbientTexture    : register(t5);
Texture2D   CavityTexture     : register(t6);
TextureCube EnvironmentTexture : register(t7);
Texture2D   _Shadow           : register(t8);

// -------------------------------------
PS_INPUT VSMain(VS_INPUT input)
{
    PS_INPUT output = (PS_INPUT)0;

    output.Position = mul(float4(input.Position, 1.0f), WorldViewProjection);
    output.WorldPosition = mul(float4(input.Position, 1.0f), World).xyz;

    // TODO: transform the light into object space instead of the normal into world space
    output.Normal = mul(input.Normal, (float3x3)World);
    output.UV0 = input.UV0;
    output.LightUV = mul(float4(input.Position, 1.0f), LightWorldViewProjection);
    output.Tangent = mul(input.Tangent, (float3x3)World);
    output.Binormal = mul(input.Binormal, (float3x3)World);

    return output;
}


//Shlick Fresnel approximation
float3 Fresnel(float3 F0, float3 h, float3 v)
{
    float vDotH = saturate(dot(v, h));

    return F0 + (1.0f - F0) * pow(2.0, (-5.55473*vDotH - 6.98316)*vDotH);
    //return F0 + (1.0f - F0) * pow((1.0f - lDotH), 5.0f);
}

float GGX_Visibility(float K, float NdotX)
{
    return NdotX / (NdotX * (1 - K) + K);
}
float3 GGX_Specular(float roughness, float3 n, float3 h, float3 v, float3 l, float3 F0)
{
    float NdotL = saturate(dot(n, l));
    if (NdotL <= 0.0f)
        return 0.0f;

    float NdotH = saturate(dot(n, h));
    float NdotV = max(dot(n, v), 0.0f);
    float NdotH2 = NdotH * NdotH;
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;

    float d = alpha2 / (3.14159 * pow(NdotH2 * (alpha2 - 1) + 1, 2.0f));

    float k = (roughness + 1)*(roughness + 1) / 8.0;
    float G = GGX_Visibility(k, NdotL)* GGX_Visibility(k, NdotV);

    float3 f = Fresnel(F0, h, v);
        return d * f * G / (4 * NdotL*NdotV);
}

float4 PSMainGGX(PS_INPUT input) : SV_Target
{
    float ambient = 1.0;
    float cavity = 0.0;

    float3 diffuseColor = 0;
    float3 specularColor = 0;

    float2 rmacScale = 1.0;
    float2 btScale = 1.0;
    float roughness = 0.0;
    float metal = 0;
    /*if (gUseRMACTexture)
    {
        float4 rmac = RMACTexture.Sample(SAMPLER0, input.UV0*rmacScale);
        roughness = rmac.x;
        metal = rmac.y;
        ambient = rmac.z;
        cavity = rmac.w;
    }
    else
    {
        roughness = gRoughness;
        metal = gMetal;
        ambient = gAmbient;
        cavity = gCavity;
    }*/
    if(gUseRoughnessTexture)
    {
        roughness = RoughnessTexture.Sample(SAMPLER0, input.UV0*rmacScale);
    }
    else
    {
        roughness = gRoughness;
    }

    if(gUseMetalTexture)
    {
        metal = MetalTexture.Sample(SAMPLER0, input.UV0*rmacScale);
    }
    else
    {
        metal= gMetal;
    }

    if(gUseAmbientTexture)
    {
        ambient = AmbientTexture.Sample(SAMPLER0, input.UV0*rmacScale);
    }
    else
    {
        ambient = gAmbient;
    }

    if(gUseCavityTexture)
    {
        cavity = CavityTexture.Sample(SAMPLER0, input.UV0*rmacScale);
    }
    else
    {
        cavity = gCavity;
    }
    float4 baseColor = 0;
    if (gUseBaseTexture)
    {
        baseColor = BaseTexture.Sample(SAMPLER0, input.UV0*btScale);
#ifdef _MAYA_
        baseColor.rgb = pow(baseColor, 2.2);
#endif
    }
    else
    {
            baseColor = gBaseColor;
    }
    diffuseColor = (1 - metal)*baseColor.rgb;
    float3 F0 = ((1 - metal)*0.04 + metal * baseColor.rgb);

    float3 n = normalize(input.Normal);
    if (gUseNormalTexture)
    {
        float3 NORMALS = NormalTexture.Sample(SAMPLER0, input.UV0*btScale).rgb * 2.0 - 1.0;
        float3x3 tangentToWorld = float3x3(-input.Tangent, -input.Binormal, input.Normal);
        n = normalize(mul(NORMALS, tangentToWorld));
        //n = normalize(mul(tangentToWorld, NORMALS));
    }
    float3 v = normalize(InverseView._m30_m31_m32 - input.WorldPosition);
    float3 r = reflect(n,v);
    float3 l = -normalize(LightDirection.xyz);
    float3 h = normalize(l + v);
    float4 result = (float4)1.0;

    result.xyz = (ambient + saturate(dot(n, l))*(1.0-cavity)) * diffuseColor + GGX_Specular(roughness, n, h, v, l, F0)*(1.0-cavity);
#ifdef _MAYA_
    result.xyz = pow(result.xyz, 1 / 2.2);
#endif
    return result;
}


technique10 Simple10
{
    pass p0
    {
        SetVertexShader(
            CompileShader(
            vs_4_0,
            VSMain()));

        SetGeometryShader(NULL);

        SetPixelShader(
            CompileShader(
            ps_4_0,
            PSMainGGX()));
    }
}

