//--------------------------------------------------------------------------------------
// Copyright 2014 Intel Corporation
// All Rights Reserved
//
// Permission is granted to use, copy, distribute and prepare derivative works of this
// software for any purpose and without fee, provided, that the above copyright notice
// and this statement appear in all copies.  Intel makes no representations about the
// suitability of this software for any purpose.  THIS SOFTWARE IS PROVIDED "AS IS."
// INTEL SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, AND ALL LIABILITY,
// INCLUDING CONSEQUENTIAL AND OTHER INDIRECT DAMAGES, FOR THE USE OF THIS SOFTWARE,
// INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PROPRIETARY RIGHTS, AND INCLUDING THE
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Intel does not
// assume any responsibility for any errors which may appear in this software nor any
// responsibility to update it.
//--------------------------------------------------------------------------------------
// Generated by ShaderGenerator.exe version 0.13
//--------------------------------------------------------------------------------------
#ifdef _MAYA_
#define MATRIX_LAYOUT
#else
#define MATRIX_LAYOUT row_major
#endif

#define USE_TANGENTS
//#define USE_UV1
// -------------------------------------
cbuffer cbPerModelValues
{
    MATRIX_LAYOUT float4x4 World                  : WORLD;
    MATRIX_LAYOUT float4x4 NormalMatrix           : WORLD;
    MATRIX_LAYOUT float4x4 WorldViewProjection    : WORLDVIEWPROJECTION;
    MATRIX_LAYOUT float4x4 InverseWorld           : WORLDINVERSE;
    MATRIX_LAYOUT float4x4 LightWorldViewProjection : SHADOWMAPMATRIX
        < 
            string Object = "Light 0";
            string UIWidget = "None";
        >;

    float4   BoundingBoxCenterWorldSpace    < string UIWidget = "None"; > ;
    float4   BoundingBoxHalfWorldSpace      < string UIWidget = "None"; > ;
    float4   BoundingBoxCenterObjectSpace   < string UIWidget = "None"; > ;
    float4   BoundingBoxHalfObjectSpace     < string UIWidget = "None"; > ;
};
// -------------------------------------
cbuffer cbPerFrameValues
{
    MATRIX_LAYOUT float4x4    View                      < string UIWidget = "None"; >;
    MATRIX_LAYOUT float4x4    InverseView : ViewInverse < string UIWidget = "None"; > ;
    MATRIX_LAYOUT float4x4    Projection                < string UIWidget = "None"; >;
    MATRIX_LAYOUT float4x4    ViewProjection            < string UIWidget = "None"; >;
    float3      AmbientColor : LIGHTCOLOR < string Object = "Light 1";>;
    float       AmbientIntensity : LIGHTINTENSITY < string Object = "Light 1";>;
    float3      LightColor : LIGHTCOLOR <string Object = "Light 0" ;>;
    float       LightIntensity : LIGHTINTENSITY < string Object = "Light 0";>;
    float4      LightDirection : Direction < string Object = "Light 0"; string Space = "World"; int Ref_ID = 0; > = { 0, 0, -1, 0 };
    float4      EyePosition               < string UIWidget = "None"; >;
    float4      TotalTimeInSeconds        < string UIWidget = "None"; > ;
};

cbuffer cbExternals
{
    float3 gBaseColor   < string UIName = "Base Color"; > = float3(0.5, 0.5, 0.5);
    float  gAlpha       < string UIName = "Alpha"; > = 1.0f;
    float2 btScale      < string UIName = "Base Texture UV Repeat"; > = float2(1.0, 1.0);
    float2 rmacScale    < string UIName = "RMAC Texture UV Repeat"; > = float2(1.0, 1.0);
    float2 globalAOScale < string UIName = "Global AO Texture UV Repeat"; > = float2(1.0, 1.0);
    float  gRoughness   < string UIName = "Roughness"; > = 0.5;
    float  gMetal       < string UIName = "Metal"; > = 0.0;
    float  gAmbient     < string UIName = "Ambient"; > = 1.0;
    float  gCavity      < string UIName = "Cavity"; > = 1.0;
    float3 gEmissive    < string UIName = "Emissive"; > = float3(0.0, 0.0, 0.0);

    bool   gUseBaseTexture      < string UIName = "Use Texture for Base Color"; > = false;
    bool   gGammaCorrectBaseTexture < string UIName = "Gamma Correct Base Texture"; > = false;
    bool   gUseNormalTexture    < string UIName = "Use Normal Map"; > = false;
    bool   g3DC                 < string UIName = "3DC compressed Normal map"; > = true;
    bool   gUseRMACTexture      < string UIName = "Use Roughness, Metal, Ambient, Cavity Texture"; >;
    bool   gUseRoughnessTexture < string UIName = "Use Roughness Texture"; > = false;
    bool   gUseMetalTexture     < string UIName = "Use Metal Texture"; > = false;
    bool   gUseAmbientTexture   < string UIName = "Use Ambient Texture"; > = false;
    bool   gUseCavityTexture    < string UIName = "Use Cavity Texture"; > = false;
    bool   gUseEnvironmentTexture < string UIName = "Use Environment Texture"; > = false;
    bool   gUseEmissiveTexture  <string UIName = "Use Emissive Texture"; > = false;
    bool   gUseGlobalAO         <string UIName = "Use Global AOTexture"; > = false;
    bool   gReceiveShadows      < string UIName = "Receives Shadows"; > = true;
};

struct VS_INPUT
{
    float3 Position : POSITION; // Projected position
    float3 Normal   : NORMAL;
    float2 UV0      : TEXCOORD0;
#ifdef USE_UV1
    float2 UV1      : TEXCOORD1;
#endif
#ifdef USE_TANGENTS
    float3 Tangent  : TANGENT;
    float3 Binormal : BINORMAL;
#endif
};

// -------------------------------------
struct PS_INPUT
{
    float4 Position     : SV_POSITION;
    float3 Normal       : NORMAL;
    float2 UV0          : TEXCOORD0;
    float2 UV1          : TEXCOORD1;
    float4 LightUV      : TEXCOORD2;
    float3 WorldPosition: TEXCOORD3;
    float3 Tangent      : TANGENT;
    float3 Binormal     : BINORMAL;
    //float3 Reflection : TEXCOORD3;
};

// -------------------------------------
SamplerState SAMPLER0  : register(s0)
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};
SamplerComparisonState SHADOW_SAMPLER : register(s1)
{
    Filter = COMPARISON_MIN_MAG_LINEAR_MIP_POINT;
    AddressU = Clamp;
	AddressV = Clamp;
    ComparisonFunc = Less_Equal;
};


Texture2D    BaseTexture         : register(t0)<int mipmaplevels = 0;>;
Texture2D    NormalTexture       : register(t1)<int mipmaplevels = 0;>;
Texture2D    RMACTexture         : register(t2)<int mipmaplevels = 0;>;
Texture2D    RoughnessTexture    : register(t3)<int mipmaplevels = 0;>;
Texture2D    MetalTexture        : register(t4)<int mipmaplevels = 0;>;
Texture2D    AmbientTexture      : register(t5)<int mipmaplevels = 0;>;
Texture2D    CavityTexture       : register(t6)<int mipmaplevels = 0;>;
TextureCube  EnvironmentTexture  : register(t7)<int mipmaplevels = 0;>;
Texture2D    EmissiveTexture     : register(t8)<int mipmaplevels = 0;>;
Texture2D    GlobalAOTexture     : register(t9)<int mipmaplevels = 0;>;
Texture2D    _Shadow             : SHADOWMAP
    < 
        string Object = "Light 0";
        string UIWiget = "None";
    >;

// -------------------------------------
PS_INPUT VSMain(VS_INPUT input)
{
    PS_INPUT output = (PS_INPUT)0;

    output.Position = mul(float4(input.Position, 1.0f), WorldViewProjection);
    output.WorldPosition = mul(float4(input.Position, 1.0f), World).xyz;

    // TODO: transform the light into object space instead of the normal into world space
    output.Normal = mul(input.Normal, (float3x3)World);
#ifdef _MAYA_
    output.UV0 = float2(input.UV0.x, 1.0-input.UV0.y);
#else
    output.UV0 = input.UV0;
#endif
#ifdef USE_UV1
#ifdef _MAYA_
    output.UV1 = float2(input.UV1.x, 1.0-input.UV1.y);
#else
    output.UV1 = input.UV1;
#endif
#endif    
    output.LightUV = mul(float4(input.Position, 1.0f), LightWorldViewProjection);
#ifdef USE_TANGENTS
    output.Tangent = mul(input.Tangent, (float3x3)World);
    output.Binormal = mul(input.Binormal, (float3x3)World);
#endif
    return output;
}

float ComputeShadowAmount(PS_INPUT input)
{
#ifdef _MAYA_
    return 1.0;
#endif
    float shadowAmount = 1.0;
    if (gReceiveShadows)
    {
        float3  lightUV = input.LightUV.xyz / input.LightUV.w;
        lightUV.xy = lightUV.xy * 0.5f + 0.5f;
        lightUV.y = 1.0f - lightUV.y;
        shadowAmount = _Shadow.SampleCmp(SHADOW_SAMPLER, lightUV.xy, lightUV.z).r;
    }
    return shadowAmount;
}
//Shlick Fresnel approximation
float3 Fresnel(float3 F0, float3 h, float3 v)
{
    float vDotH = saturate(dot(v, h));

    return F0 + (1.0f - F0) * pow(2.0, (-5.55473*vDotH - 6.98316)*vDotH);
    //return F0 + (1.0f - F0) * pow((1.0f - lDotH), 5.0f);
}

float GGX_Visibility(float K, float NdotX)
{
    return NdotX / (NdotX * (1 - K) + K);
}

float3 GGX_Specular(float roughness, float3 n, float3 h, float3 v, float3 l, float3 F0)
{
    float NdotL = saturate(dot(n, l));
    float NdotV = saturate(dot(n, v));
    if (NdotL <= 0.0f || NdotV <= 0.0f)
        return 0.0f;

    float NdotH = saturate(dot(n, h));
    float NdotH2 = NdotH * NdotH;
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;

    float d = alpha2 / (3.14159 * pow(NdotH2 * (alpha2 - 1) + 1, 2.0f));

    float k = (roughness + 1)*(roughness + 1) / 8.0;
    float G = GGX_Visibility(k, NdotL)* GGX_Visibility(k, NdotV);
    
    float3 f = Fresnel(F0, h, v);
    
    return d * f * G / (4 * NdotL*NdotV);
}
float4 PSShadow(PS_INPUT input) : SV_Target
{
    return input.Position.z/input.Position.w;
}

float4 PSMain(PS_INPUT input) : SV_Target
{
    float4 result = (float4)0.0;

    float roughness = gRoughness;
    float metal = gMetal;
    float ambient = gAmbient;
    float cavity = gCavity;

    if (gUseRMACTexture)
    {
        float4 rmac = RMACTexture.Sample(SAMPLER0, input.UV0*rmacScale);
        roughness = rmac.x;
        metal = rmac.y;
        ambient = rmac.z;
        cavity = rmac.w;
    }
    if(gUseRoughnessTexture)
    {
        roughness = RoughnessTexture.Sample(SAMPLER0, input.UV0*rmacScale).r;
    }
    if(gUseMetalTexture)
    {
        metal = MetalTexture.Sample(SAMPLER0, input.UV0*rmacScale).r;
    }
    if(gUseAmbientTexture)
    {
        ambient = AmbientTexture.Sample(SAMPLER0, input.UV0*rmacScale).r;
    }
    if(gUseGlobalAO)
    {
        ambient *= GlobalAOTexture.Sample(SAMPLER0, input.UV1*globalAOScale).r;
    }

    if(gUseCavityTexture)
    {
        cavity = CavityTexture.Sample(SAMPLER0, input.UV0*rmacScale).r;
    }

    float3 baseColor = gBaseColor;
    result.a = gAlpha;
    if (gUseBaseTexture)
    {
        float4 texRead = BaseTexture.Sample(SAMPLER0, input.UV0*btScale);
        baseColor = BaseTexture.Sample(SAMPLER0, input.UV0*btScale).rgb;
        result.a = texRead.a;
#ifdef _MAYA_
        if (gGammaCorrectBaseTexture == true)
        {
            baseColor = pow(baseColor, 2.2);
        }
#endif

    }
    float3 diffuseColor = (1 - metal)*baseColor.rgb;
    float3 F0 = ((1 - metal)*0.04 + metal * baseColor.rgb);

    float3 n = normalize(input.Normal);
    if (gUseNormalTexture)
    {
        if (g3DC)
        {
            float2 texread = NormalTexture.Sample(SAMPLER0, input.UV0*btScale).rg * 2.0 - 1.0;
            float2 rg2 = texread.rg*texread.rg;
            float b = sqrt(1.0 - rg2.x - rg2.y);
            float3 NORMALS = float3(texread.rg, b);
            float3x3 tangentToWorld = float3x3(input.Tangent, input.Binormal, input.Normal);
            n = normalize(mul(NORMALS, tangentToWorld));

        }
        else //uncompressed normal map
        {
            float3 NORMALS = NormalTexture.Sample(SAMPLER0, input.UV0*btScale).rgb * 2.0 - 1.0;
            float3x3 tangentToWorld = float3x3(input.Tangent, input.Binormal, input.Normal);
            n = normalize(mul(NORMALS, tangentToWorld));
        }
        //float len = length(NORMALS);
        //float p = 2.0 / (roughness*roughness) + 2.0;
        //float alpha = 2.0 / (1-p*len / lerp(p, 1.0, len));
        //roughness = sqrt(saturate(alpha));
    }
    float3 v = normalize(InverseView._m30_m31_m32 - input.WorldPosition);

    const float4 c0 = float4 (-1.0, -0.0275, -0.572, 0.022);
    const float4 c1 = float4 (1.0, 0.0425, 1.04, -0.04);
    float4 rr = roughness * c0 + c1;
    float3 r = reflect(v, n);
    float3 l = -normalize(LightDirection.xyz);
    float3 h = normalize(l + v);
    float a004 = min(rr.x*rr.x, exp2(-9.28*dot(n, v))) * rr.x + rr.y;
    float2 AB = float2(-1.04, 1.04) * a004 + rr.zw;
    float3 ambSpecColor = F0.rgb*AB.x + AB.y;

    float3 ambientDiffuse = diffuseColor*AmbientColor.rgb;
    float3 ambientSpecular = ambSpecColor*AmbientColor.rgb;
    if(gUseEnvironmentTexture)
    {    
        uint mip = 0, width, height, nummips;
        EnvironmentTexture.GetDimensions(mip, width, height, nummips);
        float3 envDiff = EnvironmentTexture.SampleLevel(SAMPLER0, n*float3(1, 1, 1), nummips-1).rgb;
        float specularSampleLevel = EnvironmentTexture.CalculateLevelOfDetail(SAMPLER0, -r)*.1 + nummips*roughness;
        float3 envSpec = EnvironmentTexture.SampleLevel(SAMPLER0, -r, specularSampleLevel).rgb;
        ambientDiffuse *= envDiff;
        ambientSpecular *= envSpec;
    }

    result.rgb = ComputeShadowAmount(input)*
        LightColor*cavity*((saturate(dot(n, l))*diffuseColor + GGX_Specular(roughness, n, h, v, l, F0)));
    
    result.rgb += ambient*(ambientDiffuse + ambientSpecular);

    if(gUseEmissiveTexture)
        result.rgb += EmissiveTexture.Sample(SAMPLER0, input.UV0*btScale).rgb;
    else
        result.rgb += gEmissive;

    return result;
}

RasterizerState DefaultRS
{
    CullMode = None;
};

RasterizerState ShadowRS
{
    CullMode = Back;
    SlopeScaledDepthBias = 1.0;
};

technique10 Opaque
{
    pass p0
    {
        SetRasterizerState(DefaultRS);
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
    }

    pass pShadow < string drawContext = "shadowPass"; >
    {
        SetRasterizerState(ShadowRS);
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSShadow()));
    }
}

technique10 OpaqueNoShadowCast
{
    pass p0
    {
        SetRasterizerState(DefaultRS);
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
    }
}

BlendState PreMultipliedAlphaBlending
{
	AlphaToCoverageEnable = FALSE;
	BlendEnable[0] = TRUE;
	SrcBlend = ONE;
	DestBlend = INV_SRC_ALPHA;
	BlendOp = ADD;
	SrcBlendAlpha = ONE;	// Required for hardware frame render alpha channel
	DestBlendAlpha = INV_SRC_ALPHA;
	BlendOpAlpha = ADD;
	RenderTargetWriteMask[0] = 0x0F;
};

technique10 PreMultipliedAlpha
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
        SetBlendState(PreMultipliedAlphaBlending, float4(0.0f, 0.0f, 0.0f, 0.0f), 0xFFFFFFFF);
    }
}

BlendState AlphaBlending
{
	AlphaToCoverageEnable = FALSE;
	BlendEnable[0] = TRUE;
	SrcBlend = SRC_ALPHA;
	DestBlend = INV_SRC_ALPHA;
	BlendOp = ADD;
	SrcBlendAlpha = ONE;	// Required for hardware frame render alpha channel
	DestBlendAlpha = INV_SRC_ALPHA;
	BlendOpAlpha = ADD;
	RenderTargetWriteMask[0] = 0x0F;
};

technique10 Alpha
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
        SetBlendState(AlphaBlending, float4(0.0f, 0.0f, 0.0f, 0.0f), 0xFFFFFFFF);
    }
}

DepthStencilState NoDepthWrite
{
    DepthWriteMask = ZERO;
    DepthFunc = Less_Equal;

};
technique10 Decal
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
        SetBlendState(AlphaBlending, float4(0.0f, 0.0f, 0.0f, 0.0f), 0xFFFFFFFF);
    }
}

technique10 DecalPreMultiplied
{
    pass p0
    {
        SetVertexShader(CompileShader(vs_4_1, VSMain()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_1, PSMain()));
        SetBlendState(PreMultipliedAlphaBlending, float4(0.0f, 0.0f, 0.0f, 0.0f), 0xFFFFFFFF);
    }
}
